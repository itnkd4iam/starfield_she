#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Nov 30, 2023 02:37:03 PM CST  platform: Windows NT
"""
    TO DO: attach itemList._perk = 'outpostengineering' to outpost modules

        ? breakdown selected items to resources - add warning that it cannot be reversed

        language selection: something like resource_jp.json containing the "resourceId": "new label" and will match/replace -- except for "mat": {}

        ? add housing items

        ? update app title based on selected tab
"""

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
from tkinter import messagebox

import time
from datetime import datetime
import os
import configparser
import json

from pathvalidate import ValidationError, validate_filename
import pyperclip
import ctypes
import webbrowser

from PIL import Image, ImageTk

import random
import re
from tktooltip import ToolTip

import starfield_she


_debug = True # False to eliminate debug printing from callback functions.

MAX_QTY = 255
SEPARATOR_MOD = ','
SEPARATOR_RANDOM_MOD = '|'
CNSL_ADDITEM = 'player.additem %itemId% %itemQty%'
CNSL_UNEQUIP = 'player.unequipitem %itemId%'
CNSL_DROP = 'player.drop %itemId% %maxQty%'
CNSL_MODITEM = 'player.cf "ObjectReference.AttachModToInventoryItem" %itemId% %modId%'
CNSL_PAUSE = 'showmenu sleepwaitmenu\nhidemenu sleepwaitmenu'
# X alt: "set gamehour to X" - crashes
# X alt: PassTime - crashes

consoleModItemCount = 0

config_file = os.path.basename(__file__)
script_name = os.path.splitext(config_file)[0]
url_file = script_name + '-url.txt'
config_file = script_name + '.ini'
config = configparser.ConfigParser()
config['SETTINGS'] = {
        'posx': 1,
        'posy': 1,
        'width': 600,
        'height': 630,
        'tab': 0,
        'sash': 0,
        'selected_save': 0,
        'max_qty': MAX_QTY,
        'data': 'outpostitems,research,resources',
        'lang': 'en'
    }


dataJSON = {}

# perksFile = './perks.json'  # for implementation
# perksJSON = {}

saveFile = './savelist.json'
saveList = {}
saveDir = './save/'
saveTemplate = './save_template.txt'
saveNameDefault = 'Default'

resDir = './res/'


ech_debug_counter = 1
def ech_debug(msg):
    global ech_debug_counter
    current_time = datetime.now()
    formatted = str(ech_debug_counter)
    formatted = "{:<4}".format(formatted)
    print( current_time.strftime('%I:%M:%S %p '), ' #',  formatted, ': ', msg )
    # sys.stdout.flush()
    ech_debug_counter += 1


def append_log(event, pFile=""):
    if not len(pFile):
        pFile = LOG_FILE

    with open(pFile, 'a', encoding='utf-8') as logfile_obj:
        logfile_obj.write( str(event) + '\n' )

# S|load_config()
def load_config():
    global config, config_file

    # ech_debug("config_path: " + config_file)
    config_path = './' + config_file
    if os.path.exists(config_path):
        # ech_debug('Read config file: ' + config_path)
        config.read(config_path, encoding='utf-8')                            # read from config file
    else:
        # ech_debug('Generate & save config file')
        save_config()

# E|load_config()


# S|save_config()
def save_config():
    global config, config_file

    config_path = './' + config_file
    # ech_debug('Updating: ' + config_path)
    with open(config_path, 'w') as configfile_obj:                      # update config file
        config.write(configfile_obj, 'utf-8')

# END|save_config()


def check_point():
    ech_debug('Checkpoint reached! Exiting script...')
    sys.exit()


def set_win_pos(win, posX, posY):
    if posX < 1:
        posX = 1

    if posY < 1:
        posY = 1

    win.geometry( f'+{posX}+{posY}' )


def set_win_dimensions(win, width, height):
    win.geometry( f'{width}x{height}' )


def about_win(show=False, create=False):
    global _top1, _w1

    w = 300
    h = 340

    # ech_debug( f'about_win()> show:{show}')

    if create:
        _top1.aboutWin = tk.Toplevel(_top1)
        _top1.aboutWin.withdraw()
        set_win_dimensions(_top1.aboutWin, w, h)
        _top1.aboutWin.title(starfield_she.PROGRAM_TITLE)
        _top1.aboutWin.iconbitmap("res/myIcon.ico")
        _top1.aboutWin.attributes('-topmost',True)
        _top1.aboutWin.resizable(0, 0)
        # _top1.aboutWin.attributes(toolwindow=1)
        _top1.aboutWin.overrideredirect(1)
        _top1.aboutWin.configure(background="#d9d9d9")

        _top1.aboutWin.logo = tk.PhotoImage(file='res/tarsier256x.png')
        _top1.aboutWin.Header = tk.Label(_top1.aboutWin, image=_top1.aboutWin.logo, compound='c', anchor='center' )
        _top1.aboutWin.Header.grid(row=0, column=0, sticky='news')

        _top1.aboutWin.ProgramName = tk.Label(_top1.aboutWin, text=starfield_she.PROGRAM_TITLE, font='Arial 10 bold', anchor='center', padx=10 )
        _top1.aboutWin.ProgramName.grid(row=1, column=0, sticky='news')

        _top1.aboutWin.Frame = ttk.Frame(_top1.aboutWin)
        _top1.aboutWin.Frame.grid(row=2, column=0, sticky='news')
        _top1.aboutWin.Frame['padding'] = (10, 5)
        _top1.aboutWin.Frame.grid_columnconfigure(1, weight=1)

        _top1.aboutWin.githubBtn = tk.Button(_top1.aboutWin.Frame, text=' @GitHub ', padx=10 )
        _top1.aboutWin.githubBtn.grid(row=0, column=0)

        _top1.aboutWin.myNFTBtn = tk.Button(_top1.aboutWin.Frame, text=' Buy my NFTs ', padx=10 )
        _top1.aboutWin.myNFTBtn.grid(row=0, column=1)

        _top1.aboutWin.tipMeBtn = tk.Button(_top1.aboutWin.Frame, text=' Tip Me! ', padx=10 )
        _top1.aboutWin.tipMeBtn.grid(row=0, column=2)


        _top1.aboutWin.closeBtn = tk.Button(_top1.aboutWin, text=' OK ', padx=10, command=lambda: _top1.aboutWin.withdraw() )
        _top1.aboutWin.closeBtn.grid(row=3, column=0, pady=10)

        _top1.aboutWin.grid_columnconfigure(0, weight=1)
        _top1.aboutWin.grid_rowconfigure(0, weight=1)

    if show:
        m = _w1.top

        posX = round( m.winfo_x() + (m.winfo_width()/2) - (w/2) )
        posY = round( m.winfo_y() + (m.winfo_height()/2) - (h/2) )

        # ech_debug( f'x,y: {posX},{posY}' )

        set_win_pos(_top1.aboutWin, posX, posY)

        _top1.aboutWin.deiconify()



# S|save_settings()
def save_settings():
    global _w1
    global saveSashPos

    # ech_debug('save_settings()')

    if _w1.top.state() == 'normal':     # normal or withdrawn
        posX = _w1.top.winfo_x()
        posY = _w1.top.winfo_y()

    config.set('SETTINGS', 'posx', str(posX) )      # save win x, y
    config.set('SETTINGS', 'posy', str(posY) )

    width = _w1.top.winfo_width()
    height = _w1.top.winfo_height()

    config.set('SETTINGS', 'width', str(width) )
    config.set('SETTINGS', 'height', str(height) )

    selected_tab = _w1.TNotebook1.index("current")

    config.set('SETTINGS', 'tab', str(selected_tab) )

    if saveSashPos:
        sashpos = _w1.TPanedwindow1.sashpos(0)
        config.set('SETTINGS', 'sash', str(sashpos) )

    selected_list = _w1.SaveList.current()
    config.set('SETTINGS', 'selected_save', str(selected_list) )

    save_config()

# E|save_settings()


def on_close():
    global root

    # check for any unsaved changes and confirm exit
    exitOK = True
    """
    if messagebox.askokcancel("Quit", "There are unsaved changes in your shopping list. Do you wish to exit without saving the changes?"):
        exitOK = True
    """

    if exitOK:
        # update config and save settings
        save_settings()

        root.destroy()

        sys.exit()


def load_json(filepath):
    c = None

    if os.path.exists(filepath):
        f = open(filepath)
        c = json.load(f)

        f.close()
    else:
        ech_debug( f'File does not exist: {filepath}' )
        sys.exit()

    return c


def save_json(fileContent, filepath):
    with open(filepath, 'w', encoding='utf-8') as co:                      # update config file
        json.dump(fileContent, co, indent=4)


# S|SelectedListItem
class SelectedListItem:
    global MAX_QTY, resDir
    global _cSelectedList

    def __init__(self, parent, o, qty=1):
        self.parent = parent

        self._o = o
        self._itemId = o.id
        self._itemName = o.name
        self._ico = o.ico
        self.tooltip = ''
        self.out = ''

        if len(o.tooltip):
            self.tooltip = o.tooltip

        if len(o.out):
            self.out = o.out

        # self.top = self

        self.create_widgets(qty)

    def create_widgets(self, qty):
        self.Frame = tk.Frame(self.parent)
        self.Frame.grid(column=0, sticky='we')
        self.parent.grid_columnconfigure(0, weight=1)

        self.Frame._o = self._o
        self.Frame._o.quantity = qty

        self._ico = tk.PhotoImage(file= f'{resDir}blank.png', width=56, height=40)
        self.ListItem = tk.Button(self.Frame, image=self._ico, text=self._itemName, height=40, compound='left', name="itemname", anchor='w', padx=10, pady=0 )       # compound='c'
        self.ListItem.pack(side=LEFT, expand=True, fill=BOTH)

        """
        if len(self.tooltip):
            self.ListItem_tooltip = starfield_she.ToolTip(self.ListItem, self.tooltip)
        """

        o = self._o
        
        if len(o.tooltip) or len(o.out):
            tMsg = o.tooltip

            if len(o.out):
                oList = o.out.split(',')
                for oItem in oList:
                    if re.search( '^[ABCDEF0123456789]{8}', oItem):
                        # ech_debug( f'SelectedListItem.create_widgets().item: {oItem}')
                        outItem = find_item_by_id(oItem)

                        if outItem:
                            if len(tMsg):
                                tMsg += '\n'

                            tMsg += f'Produces: {outItem.name}'

                    else:
                        tMsg += oItem + '\n'


            if len(tMsg):
                self._tooltip_msg = tMsg
                self.set_tooltip_msg(tMsg)
                self._tooltip = ToolTip(self.ListItem, msg=self.get_tooltip_msg, follow=True )
                self._tooltip.attributes('-topmost',True)


        # quantity button
        maxValue = MAX_QTY
        # check max value from self.Frame._o
        if type( self.Frame._o.max_qty ) is int:
            # ech_debug( f'maxValue: {self.Frame._o.max_qty}' )
            maxValue = self.Frame._o.max_qty

        if maxValue < 1:
            maxValue = 1

        self.SpinBoxVal = tk.StringVar()
        self.SpinBox = tk.Spinbox(self.Frame, from_=1, to=maxValue, command=lambda: self.update_quantity(self.SpinBox.get()), textvariable=self.SpinBoxVal)
        self.SpinBox.place(relx=1, x=-82, rely=0.5, y=-12, width=40, height=24)
        self.SpinBoxVal.set( qty )
        if maxValue == 1:
            self.SpinBox["state"] = "readonly"

        self.SpinBoxVal.trace_add('write', self.check_quantity)
        self.SpinBox.bind( '<FocusOut>', lambda e: self.update_quantity(self.SpinBox.get()) )

        self.DelButton = tk.Button(self.Frame, text='üóë', command=lambda: self.rem(self.Frame) )       # Delete button
        self.DelButton.place(relx=1, x=-35, rely=0.5, y=-12, height=24, width=24)


    def rem(self, obj):
        thisRow = obj.grid_info()["row"]
        # ech_debug( f'thisRow: {thisRow}' )

        obj.destroy()

        # update row order
        # look for row >= thisRow and adjust-1
        for sItem in _cSelectedList.SelectedList.winfo_children():
            cRow = sItem.grid_info()["row"]
            if cRow >= thisRow:
                sItem.grid(row=cRow-1)

        update_materials_list()


    def update_quantity(self, qty):
        # ech_debug( f'update_quantity(): {qty}' )
        if not len(qty) or int(qty) <= 0:
            qty = '1'
            self.SpinBoxVal.set( qty )

        self.Frame._o.quantity = int(qty)

        update_materials_list()

        self.ListItem.focus_set()


    def check_quantity(self, pVar, pIdx, pMode):
        if len( self.SpinBoxVal.get() ):
            qty = int( self.SpinBoxVal.get() )
            if qty > 0:
                # ech_debug( f'SelectedListItem.check_quantity: {qty}' )

                self.Frame._o.quantity = qty

                update_materials_list()


    def set_tooltip_msg(self, txt):
        self._tooltip_msg = txt

    def get_tooltip_msg(self):
        # ech_debug( f'get_tooltip_msg(): {self._tooltip_msg}' )
        return self._tooltip_msg


# E|SelectedListItem


# S|SelectedList
class SelectedList:
    def __init__(self, parent):
        self.parent = parent

        self.create_widgets()


    def create_widgets(self):
        self.Frame2 = tk.Frame( self.parent )
        self.Frame2.place(x=10, y=20, relheight=1
                , relwidth=1, width=-20, height=-30, bordermode='ignore')
        self.Frame2.configure(relief='groove')
        self.Frame2.configure(borderwidth="2")

        self.Canvas = tk.Canvas(self.Frame2)
        self.Canvas.grid(row=0, column=0, sticky='news')

        # create right scrollbar and connect to canvas Y
        self.VerticalBar = tk.Scrollbar(self.Frame2, orient='vertical', command=self.Canvas.yview)
        self.VerticalBar.grid(row=0, column=1, sticky='ns')
        self.Canvas.configure(yscrollcommand=self.VerticalBar.set)

        # inner frame for widgets
        self.SelectedList = tk.Frame(self.Canvas, name='selectedlist' )
        self.InnerWindow = self.Canvas.create_window((0, 0), window=self.SelectedList, anchor='nw')

        # autoresize inner frame
        self.Frame2.columnconfigure(0, weight=1)
        self.Frame2.rowconfigure(0, weight=1)

        # resize when configure changed
        self.SelectedList.bind('<Configure>', self.resize)
        self.Canvas.bind('<Configure>', self.frame_width)

        self.Frame2.bind('<Enter>', lambda e: starfield_she._bound_to_mousewheel(e, self.Frame2))
        self.Frame2.bind('<Leave>', lambda e: starfield_she._unbound_to_mousewheel(e, self.Frame2))


    def frame_width(self, event):
        # resize inner frame to canvas size
        canvas_width = event.width
        # ech_debug( f'canvas_width: {canvas_width}' )
        if hasattr( _w1.CheckList, 'warningMsg' ):
            _w1.CheckList.warningMsg.configure( wraplength=canvas_width )
        self.Canvas.itemconfig(self.InnerWindow, width = canvas_width)


    def resize(self, event=None):
        self.Canvas.configure(scrollregion=self.Canvas.bbox('all'))


# E|SelectedList


# S|create_selected_list()
def create_selected_list():
    global _top1, _w1
    global _cSelectedList

    sList = SelectedList( _w1.TPanedwindow1_p1 )
    _cSelectedList = sList

# E|create_selected_list()


# S|OutpostItem
class OutpostItem:
    global MAX_QTY

    def __init__(self, json):
        self.id = ''
        self.name = ''
        self.ico = json['ico']
        self.mat = json['mat']
        self.tooltip = ''
        self.out = ''
        self.max_qty = None

        if 'tooltip' in json:
            self.tooltip = json['tooltip']

        if 'out' in json:
            self.out = json['out']

        if 'max_qty' in json:
            self.max_qty = json['max_qty']

        for iKey in json:
            if iKey.find("_") == 0:
                setattr(self, iKey, json[iKey])
            elif iKey not in ['ico', 'mat', 'out', 'tooltip', 'max_qty'] and (iKey.find("_") > 0 or iKey.find("_") == -1):
                self.id = iKey
                self.name = json[iKey]
                # break
# E|OutpostItem


# S|ListItem
class ListItem:
    global resDir

    def __init__(self, parent, thisItem, itemList=None):
        self.parent = parent
        self._itemId = thisItem.id
        self._itemName = thisItem.name
        self._itemList = itemList
        self._o = thisItem
        self._tooltip_msg = ''
        self.create_widgets()


    def create_widgets(self):
        self.Frame = tk.Frame(self.parent)
        self.Frame.pack(fill=BOTH, expand=True)

        imgFile = f'{resDir}blank.png'
        self._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
        self.ListItem = tk.Button(self.Frame, image=self._ico, text=self._itemName, height=40, compound='left', command=lambda: add_selection(self._item), anchor='w', padx=10, pady=0 )        # compound='c', image hack: including an image will tell python to use pixels unit for the dimensions
        self.ListItem.pack(side=LEFT, expand=True, fill=BOTH)

        o = self._o

        if len(o.tooltip) or len(o.out):
            tMsg = o.tooltip

            if len(o.out):
                oList = o.out.split(',')
                for oItem in oList:
                    if re.search( '^[ABCDEF0123456789]{8}', oItem):
                        # ech_debug( f'NotebookTab.Tree.outItem: {oItem}')
                        outItem = find_item_by_id(oItem)

                        if outItem:
                            if len(tMsg):
                                tMsg += '\n'

                            tMsg += f'Produces: {outItem.name}'

                    else:
                        tMsg += oItem + '\n'


            # listItem._tooltip = starfield_she.ToolTip(listItem.ListItem, o.tooltip)
            if len(tMsg):
                self._tooltip_msg = tMsg
                self.set_tooltip_msg(tMsg)
                # self._tooltip = starfield_she.ToolTip(self.ListItem, msg=self.get_tooltip_msg  )
                self._tooltip = ToolTip(self.ListItem, msg=self.get_tooltip_msg, follow=True )
                self._tooltip.attributes('-topmost',True)


        if type(self._itemList) is list and len(self._itemList) > 1:
            self._itemIdx = 1             # for simplification, initial value will always be the first element in the array (if any)
            self.ListItem.configure( text= f'{self._itemName}  (1/{len(self._itemList)})' )

            self.PrevButton = tk.Button(self.Frame, text='‚è¥', command=self.prev_item)       # previous item
            self.PrevButton.place(relx=1, x=-63, rely=0.5, y=-12, height=24, width=24)

            self.NextButton = tk.Button(self.Frame, text='‚èµ', command=self.next_item)       # next item
            self.NextButton.place(relx=1, x=-35, rely=0.5, y=-12, height=24, width=24)

    def next_item(self):
        listLen = len(self._itemList)

        # ech_debug( f'next_item(): {listLen}' )
        # ech_debug( f'current itemId: {self._itemId}' )
        # ech_debug( f'current index: {self._itemIdx}' )
        if self._itemIdx < listLen:
            self._itemIdx += 1
        else:
            self._itemIdx = 1

        o = OutpostItem( self._itemList[ self._itemIdx-1 ] )
        self._item = o
        self._itemId = o.id
        self._itemName = o.name

        imgFile = f'{resDir}blank.png'
        if o.ico != '':
            imgFile = f'{resDir}{o.ico}'

        if os.path.exists(imgFile):
            self._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
            self.ListItem.configure(image=self._ico)
            # ech_debug( f'next item: {o.name}: {o.ico}' )
        else:
            ech_debug( f'"{o.ico}" doesn''t exist!' )

        self.ListItem.configure( text= f'{self._itemName}  ({self._itemIdx}/{listLen})' )

        tMsg = ''
        if len(o.tooltip) or len(o.out):
            tMsg = o.tooltip

            if len(o.out):
                oList = o.out.split(',')
                for oItem in oList:
                    if re.search( '^[ABCDEF0123456789]{8}', oItem):
                        # ech_debug( f'class.ListItem.next_item: {oItem}')
                        outItem = find_item_by_id(oItem)

                        if outItem:
                            if len(tMsg):
                                tMsg += '\n'

                            tMsg += f'Produces: {outItem.name}'
                    else:
                        tMsg += oItem + '\n'

        self._tooltip_msg = tMsg
        # ech_debug( f'next_item.tooltip: {self._tooltip_msg}' )
        self.set_tooltip_msg(tMsg)


    def prev_item(self):
        listLen = len(self._itemList)

        # ech_debug( f'prev_item(): {len(self._itemList)}' )
        # ech_debug( f'current itemId: {self._itemId}' )
        # ech_debug( f'current index: {self._itemIdx}' )

        if self._itemIdx > 1:
            self._itemIdx -= 1
        else:
            self._itemIdx = listLen

        o = OutpostItem( self._itemList[ self._itemIdx-1 ] )
        self._item = o
        self._itemId = o.id
        self._itemName = o.name

        # ech_debug( f'prev item: {o.name}' )

        imgFile = f'{resDir}blank.png'
        if o.ico != '':
            imgFile = f'{resDir}{o.ico}'

        if os.path.exists(imgFile):
            self._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
            self.ListItem.configure(image=self._ico)
            # ech_debug( f'prev item: {o.name}: {o.ico}' )
        else:
            ech_debug( f'"{o.ico}" doesn''t exist!' )

        self.ListItem.configure( text= f'{self._itemName}  ({self._itemIdx}/{listLen})' )

        tMsg = ''
        if len(o.tooltip) or len(o.out):
            tMsg = o.tooltip

            if len(o.out):
                oList = o.out.split(',')
                for oItem in oList:
                    if re.search( '^[ABCDEF0123456789]{8}', oItem):
                        # ech_debug( f'class.ListItem.next_item: {oItem}')
                        outItem = find_item_by_id(oItem)

                        if outItem:
                            if len(tMsg):
                                tMsg += '\n'

                            tMsg += f'Produces: {outItem.name}'
                    else:
                        tMsg += oItem + '\n'

        self._tooltip_msg = tMsg
        # ech_debug( f'prev_item.tooltip: {self._tooltip_msg}' )
        self.set_tooltip_msg(tMsg)

    def set_tooltip_msg(self, txt):
        self._tooltip_msg = txt

    def get_tooltip_msg(self):
        # ech_debug( f'get_tooltip_msg(): {self._tooltip_msg}' )
        return self._tooltip_msg


# E|outpost_item()


"""
S|NotebookTab
    scrollable items based on the ff code:

    https://stackoverflow.com/questions/47727404/how-to-add-a-scrollbar-to-window-made-with-tkinter
"""
class NotebookTab:
    global resDir

    def __init__(self, parent, tabIndex, tabName, tabItems, layout='default', sortDir='default' ):
        self.parent = parent
        self._tabIndex = tabIndex
        self._tabName = tabName

        # ech_debug( f'NotebookTab: tabIndex: {tabIndex}, tabName: {tabName}, sortDir: {sortDir}' )
        self.create_widgets()

        # ech_debug( f'Sort Direction: {sortDir}' )

        # create items
        # ech_debug( f'tabName: {tabName}' )
        rowCounter = 0

        # S|tree layout
        if layout == 'tree':

            # list:          # array []
            lRowCounter = 0
            for researchGroup in tabItems:
                # ech_debug( f'item: {researchGroup}    type: {type(tabItems[researchGroup])}' )
                if '_sort' in tabItems:
                    sortDir = tabItems['_sort']

                tabGroup = tabItems[researchGroup]
                if type(tabGroup) == list:
                    # ech_debug( 'list layout' )
                    imgFile = f'{resDir}blank.png'
                    self.Header_ico = tk.PhotoImage(file=imgFile, width=1, height=1)
                    self.Header = tk.Label( self.ListGroup, text=researchGroup, height=40, image=self.Header_ico, compound='c', font='Arial 10 bold', anchor='w', padx=10 )
                    self.Header.configure( background='#c9c9c9' )
                    self.Header.pack(expand=True, fill=BOTH)

                    # self.Header_toggle = tk.Button(self.Header, text='-')
                    self.Header_toggle = tk.Button(self.Header, text='+')               # '‚ñº' toggle button to collapse/expand occasionally disappear until mouse pointer hovers on it
                    self.Header_toggle.configure( background='#c9c9c9' )
                    self.Header_toggle.place(anchor='e', relx=1, rely=0.5, x=-10, width=24, height=24)

                    self.ResearchGroup = tk.Frame( self.ListGroup )
                    self.ResearchGroup.pack(side=TOP, fill=BOTH, expand=True)

                    self.Header_toggle.configure( command=lambda thisHeader=self.Header, thisButton=self.Header_toggle, thisContent=self.ResearchGroup: self.toggle_list(thisHeader, thisButton, thisContent) )

                    # for nItem in tabItems[researchGroup]:

                    # S|sorting     -- for testing
                    if sortDir == 'asc' or sortDir == 'desc':
                        reverse = True if sortDir == 'desc' else False
                        # ech_debug( f'{tabGroup}' )

                        tabGroup = sorted( tabGroup, key=lambda d: d[ list(d.keys())[0] ], reverse=reverse)
                    # E|sorting

                    for nItem in tabGroup:
                        i1 = nItem
                        if type(nItem) is list:
                            i1 = nItem[0]

                        o = OutpostItem(i1)
                        listItem = ListItem(self.ResearchGroup, o, nItem)
                        listItem._item = o

                        if o.ico != '':
                            imgFile = f'{resDir}{o.ico}'
                            if os.path.exists(imgFile):
                                listItem._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
                                listItem.ListItem.configure(image=listItem._ico)
                                # ech_debug( f'{o.name}: {o.ico}' )
                            else:
                                ech_debug( f'"{o.ico}" doesn''t exist!' )

                        listItem.Frame.pack_forget()

                    lRowCounter += 1

                    # self.Header_toggle.lift()                                           # attempt as a fix for the disappearing button -- doesn't work

                    self.ResearchGroup.configure(height=1)

                rowCounter += 1

        # E|tree layout
        # S|tab + list layout
        else:
            # S|sorting
            if sortDir == 'asc' or sortDir == 'desc':
                reverse = True if sortDir == 'desc' else False
                # ech_debug( f'{tabItems}' )

                tabItems = sorted( tabItems, key=lambda d: d[ list(d.keys())[0] ], reverse=reverse)
            # E|sorting

            for nItem in tabItems:
                # ech_debug( f'type: {type(nItem)}' )
                i1 = nItem
                if type(nItem) is list:
                    i1 = nItem[0]

                # ech_debug( f'i1: {i1}' )

                o = OutpostItem(i1)
                listItem = ListItem(self.ListGroup, o, nItem)
                listItem._item = o

                if o.ico != '':
                    imgFile = f'{resDir}{o.ico}'
                    if os.path.exists(imgFile):
                        listItem._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
                        listItem.ListItem.configure(image=listItem._ico)
                        # ech_debug( f'{o.name}: {o.ico}' )
                    else:
                        ech_debug( f'"{o.ico}" doesn''t exist!' )

                rowCounter += 1
        # E|tab + list layout


    def create_widgets(self):
        self.TabFrame = tk.Frame( self.parent )         # self.TabFrame == self.TNotebook1_t2
        self.parent.add( self.TabFrame, padding=3 )
        self.parent.tab( self._tabIndex, text=self._tabName, compound='left', underline='-1' )

        self.TabFrame.configure(background="#d9d9d9")
        self.TabFrame.configure(highlightbackground="#d9d9d9")
        self.TabFrame.configure(highlightcolor="black")

        self.Frame1 = tk.Frame(self.TabFrame)
        self.Frame1.place(x=10, y=10, relheight=1, height=-20, relwidth=1, width=-20)
        self.Frame1.configure(relief='flat')
        self.Frame1.configure(borderwidth="2")
        self.Frame1.configure(background="#d9d9d9")

        self.Label1 = tk.Label(self.Frame1 )
        self.Label1.grid(row=0, column=0, pady=5, sticky='ew')
        self.Label1.configure(anchor='w')
        self.Label1.configure(background="#d9d9d9")
        self.Label1.configure(compound='left')
        self.Label1.configure(disabledforeground="#a3a3a3")
        self.Label1.configure(foreground="#000000")
        self.Label1.configure(text=self._tabName)
        self.Label1.configure(font='Arial 12 bold')

        self.Frame2 = tk.Frame(self.Frame1)
        self.Frame2.grid(row=1, column=0, pady=5, sticky='news')
        self.Frame2.configure(borderwidth="0")

        self.Frame1.rowconfigure(1, weight=1)
        self.Frame1.columnconfigure(0, weight=1)

        self.Frame2.rowconfigure(0, weight=1)
        self.Frame2.columnconfigure(0, weight=1)


        self.Canvas = tk.Canvas(self.Frame2)
        self.Canvas.grid(row=0, column=0, sticky='news')

        # create right scrollbar and connect to canvas Y
        self.VerticalBar = tk.Scrollbar(self.Frame2, orient='vertical', command=self.Canvas.yview)
        self.VerticalBar.grid(row=0, column=1, sticky='ns')
        self.Canvas.configure(yscrollcommand=self.VerticalBar.set)

        # inner frame for widgets
        self.ListGroup = tk.Frame(self.Canvas)
        self.InnerWindow = self.Canvas.create_window((0, 0), window=self.ListGroup, anchor='nw')

        # resize when configure changed
        self.ListGroup.bind('<Configure>', self.resize)
        self.Canvas.bind('<Configure>', self.frame_width)

        self.Frame2.bind('<Enter>', lambda e: starfield_she._bound_to_mousewheel(e, self.Frame2))
        self.Frame2.bind('<Leave>', lambda e: starfield_she._unbound_to_mousewheel(e, self.Frame2))


    def frame_width(self, event):
        # resize inner frame to canvas size
        canvas_width = event.width
        self.Canvas.itemconfig(self.InnerWindow, width = canvas_width)

    def resize(self, event=None):
        self.Canvas.configure(scrollregion=self.Canvas.bbox('all'))


    def toggle_list(self, widget, toggleButton, contentGroup):
        # ech_debug( f'{widget["text"]}' )
        # ech_debug( f'{self.Header_toggle["text"]}' )
        # ech_debug( f'{toggleButton["text"]}' )
        if toggleButton["text"] != '-':                 # '‚ñº'
            toggleButton.configure( text='-' )          # '‚ñ≤'
            # ech_debug( 'expand list' )

            # contentGroup.pack(side=TOP, fill=BOTH, expand=True)                   # bug: contentGroup.children() appended at end

            for listItem in contentGroup.winfo_children():
                listItem.pack(fill=BOTH, expand=True)

        else:
            toggleButton.configure( text='+' )        # '‚ñº'
            # ech_debug( 'collapse list' )

            # contentGroup.pack_forget()            # works but using pack() appends the children at the very end

            for listItem in contentGroup.winfo_children():
                # ech_debug( type(listItem) )
                listItem.pack_forget()

            contentGroup.configure(height=1)



# E|NotebookTab


# S|load_json_data()
def load_json_data():
    global dataJSON, config

    jsonList = config.get('SETTINGS', 'data').split(',')
    for fileName in jsonList:
        if len(fileName):
            jsonFile = f'{fileName}.json'

            if os.path.exists(jsonFile):
                dataJSON[fileName] = load_json(jsonFile)

# E|load_json_data()


# S|create_tabs()
def create_tabs():
    global _top1, _w1, dataJSON, config

    tabCounter = 1

    # ignoreKeys = ['_layout']

    jsonList = config.get('SETTINGS', 'data').split(',')
    for fileName in jsonList:
        if fileName in dataJSON:

            layout = 'default'
            tmpJSON = dataJSON[fileName]
            if '_layout' in tmpJSON:
                layout = tmpJSON['_layout']

            sortDir = 'default'
            if '_sort' in tmpJSON:
                sortDir = tmpJSON['_sort']

            # ech_debug( f'Sort Direction: {sortDir2}' )

            for tab_name in tmpJSON:
                # ech_debug( f'{tab_name}: {type(tmpJSON[tab_name])}' )
                if (tab_name.find("_") > 0 or tab_name.find("_") == -1):
                    NotebookTab( _w1.TNotebook1, tabCounter, tab_name, tmpJSON[tab_name], layout=layout, sortDir=sortDir )
                    # ech_debug( f'item_len: {len(tmpJSON[tab_name])}' )
                    tabCounter += 1

# E|create_tabs()


def prev_tab(event=None):
    global _top1, _w1

    max = _w1.TNotebook1.index(tk.END)-1
    current = _w1.TNotebook1.index("current")

    if current > 0:
        _w1.TNotebook1.select(current-1)



def next_tab(event=None):
    global _top1, _w1

    max = _w1.TNotebook1.index(tk.END)-1
    current = _w1.TNotebook1.index("current")

    if current < max:
        _w1.TNotebook1.select(current+1)



def all_children (wid) :
    _list = wid.winfo_children()

    for item in _list :
        if item.winfo_children() :
            _list.extend(item.winfo_children())

    return _list


def get_selected_list():
    global _w1

    return _w1.top.nametowidget('.!notebook.!frame.!panedwindow.!labelframe.!frame.!canvas.selectedlist')


# S|enum_selected_items()
def enum_selected_items():
    global CNSL_ADDITEM, CNSL_UNEQUIP, CNSL_DROP, CNSL_MODITEM, consoleModItemCount, MAX_QTY

    selList = get_selected_list()
    out = { 'items': {}, 'items_text': '', 'resources': '', 'console': '' }
    matList = {}
    textFinal = []

    hasMod = False
    consoleModItemCount = 0
    modItemList = []
    tMod = '_mod%id%'

    for sItem in selList.winfo_children():
        # get materials from sItem._o.mat
        qty = sItem._o.quantity                                                 # APPLY PERK as necessary

        # ech_debug( f'{sItem._o.name}: {sItem._o.mat} * {sItem._o.quantity}'  )

        # change to { id:, name:, q: } and sort by name
        textFinal.append( (sItem._o.name, 'x' + str(qty) ) )
        for mat in sItem._o.mat:
            if (mat.find("_") > 0 or mat.find("_") == -1):                      # ignore special keys
                modKey = tMod.replace('%id%', mat)
                # ech_debug( f'modKey: {modKey}' )
                if modKey in sItem._o.mat:
                    hasMod = True
                    consoleModItemCount += 1
                    if mat not in modItemList:
                        modItemList.append( mat )


                if mat in matList:
                    matList[mat] += (sItem._o.mat[mat] * qty)
                else:
                    matList[mat] = (sItem._o.mat[mat] * qty)

    # ech_debug( f'hasMod: {hasMod}' )

    lens = []
    itemsList = ''
    for col in zip(*textFinal):
        lens.append(max([len(v) for v in col]))
    format = "  ".join(["{:<" + str(l) + "}" for l in lens])
    for row in textFinal:
        itemsList += format.format(*row) + '\n'

    tmp1 = []
    textFinal = []
    for matId in matList:
        qty = matList[matId]

        tmp2 = find_item_by_id(matId)
        matIco = ''
        if tmp2:
            matName = tmp2.name
            matIco = tmp2.ico
        else:
            matName = matId

        tmp1.append( { 'id': matId, 'name': matName, 'q': qty, 'ico': matIco } )


    sortedList = sorted(tmp1, key=lambda d: d['name'])


    for item in sortedList:
        textFinal.append( (item['name'], 'x' + str(item['q']) ) )

    lens = []
    txtMatList = ''

    for col in zip(*textFinal):
        lens.append(max([len(v) for v in col]))
    format = "  ".join(["{:<" + str(l) + "}" for l in lens])
    for row in textFinal:
        txtMatList += format.format(*row) + '\n'

    # S|generate console command
    consoleCommand = ''
    for mat in sortedList:
        if mat['id'] not in modItemList:
            consoleCommand += CNSL_ADDITEM.replace( '%itemId%', mat['id'] ).replace( '%itemQty%', str( mat['q'] ) ).replace( '%itemName%', mat['name'] ) + '\n'

    # S|generate console commands for modded items
    if hasMod:
        modCounter = 0
        # ech_debug( f'{consoleModItemCount}x Item(s) has modifiers: {modItemList}' )
        # ech_debug( 'Generate modded items' )

        consoleCommand = ';;*WARNING* Using console commands could break your game!\n;;Run these commands in a batch file to be executed properly.\n;;If you\'re still having trouble, separate each modded items in its own batch file and run separately.\n\n' + consoleCommand

        for sItem in selList.winfo_children():
            # ech_debug( f'sItem._o.id: {sItem._o.id}' )
            for mat in sItem._o.mat:

                modKey = tMod.replace('%id%', mat)

                if mat in modItemList and modKey in sItem._o.mat:
                    itemName = sItem._o.name
                    itemId = mat

                    consoleCommand += CNSL_PAUSE + '\n'     # pause to properly create modded item

                    # if consoleModItemCount > 1:
                    consoleCommand += f';;S|commands to create the modded {itemName} --------\n'

                    consoleCommand += CNSL_UNEQUIP.replace( '%itemId%', itemId ) + '\n'
                    consoleCommand += CNSL_DROP.replace( '%itemId%', itemId  ).replace( '%maxQty%', '100' ) + '\n'
                    consoleCommand += CNSL_ADDITEM.replace( '%itemId%', itemId ).replace( '%itemQty%', '1' ) + '\n'

                    # SEPARATOR_MOD = ','
                    # SEPARATOR_RANDOM_MOD = '|'
                    # CNSL_MODITEM = 'player.cf "ObjectReference.AttachModToInventoryItem" %itemId% %modId%'
                    modList = sItem._o.mat[modKey].split(SEPARATOR_MOD)

                    # ech_debug( f'Mods: {modList}' )
                    if len(modList) > 0 and len(modList[0]) > 0:
                        for itemMod in modList:
                            randMod = itemMod.split(SEPARATOR_RANDOM_MOD)
                            if len(randMod) > 0:
                                consoleCommand += CNSL_MODITEM.replace( '%itemId%', itemId ).replace( '%modId%', random.choice( randMod ) ) + '\n'
                            else:
                                consoleCommand += CNSL_MODITEM.replace( '%itemId%', itemId ).replace( '%modId%', randMod[0] ) + '\n'

                    # if consoleModItemCount > 1:
                    consoleCommand += f';;--------- E|commands to create the modded {itemName} \n\n'
    # E|generate console commands for modded items

    # E|generate console command


    out['items'] = sortedList
    out['items_text'] = itemsList
    out['resources'] = txtMatList
    out['console'] = consoleCommand


    return out

# E|enum_selected_items()


def json_search_items(id, json):
    out = {}

    if type(json) is list:          # array []
        for e in json:
            # ech_debug( f'e: {e}' )
            out = json_search_items(id, e)
            if out:
                break

    elif type(json) is dict:        # dict {}
        if id in json:          # json{} contains all the info for id - applies for OutpostItems.json
            out = json
        else:
            for e in json:
                if (e.find("_") > 0 or e.find("_") == -1) and e != 'mat':         # ignore special keys (ie: _layout) and mat{}
                # ech_debug( f'e: {e}' )
                    out = json_search_items(id, json[e])
                    if out:
                        break

    return out



# S|find_item_by_id()
def find_item_by_id(itemId):
    global dataJSON

    o = {}

    for fileName in dataJSON:
        tmp = json_search_items( itemId, dataJSON[fileName] )
        if tmp:
            o = OutpostItem( tmp )
            break

    return o

# E|find_item_by_id()



# S|get_selected_item_from_row()
def get_selected_item_from_row(rIndex):
    global _cSelectedList

    o = None

    sList = _cSelectedList.SelectedList
    for sItem in sList.winfo_children():
        if sItem.grid_info()["row"] == rIndex:
            o = sItem
            break

    return o
# E|get_selected_item_from_row()


"""
S|add_selection()


"""
def add_selection(o, qty=1):
    global _top1, _w1
    global _cSelectedList

    addOK = True

    # ech_debug( f'add_selection(): {o.id}' )

    # sList = get_selected_list()
    sList = _cSelectedList.SelectedList

    # ech_debug( f'sList.winfo_children().len: {len(sList.winfo_children())}' )     - works

    for sItem in sList.winfo_children():
        # ech_debug( f'sItem._itemId: {sItem._o.id}' )
        # ech_debug( f'sItem._itemName: {sItem._o.name}' )
        if o.id == sItem._o.id:
            addOK = False
            break

    if addOK:
        itemFrame = SelectedListItem(sList, o, qty)
        curFrame = itemFrame.Frame

        if o.ico != '':
            imgFile = f'{resDir}{o.ico}'
            if os.path.exists(imgFile):
                itemFrame._ico = tk.PhotoImage(file=imgFile, width=56, height=40)
                itemFrame.ListItem.configure(image=itemFrame._ico)
                # ech_debug( f'{o.name}: {o.ico}' )
            else:
                ech_debug( f'"{o.ico}" doesn''t exist!' )


        clen = len( sList.winfo_children() )

        curFrame.grid(row=clen-1)

        # S|sort
        curKey = curFrame.children["itemname"].cget("text")

        hasChanged = False
        if clen > 1:
            lastIndex = clen-1

            while True:
                prevFrame = get_selected_item_from_row(lastIndex-1)
                prevKey = prevFrame.children["itemname"].cget("text")

                if curKey < prevKey:        # swap posn
                    hasChanged = True

                    curFrame.grid( row=lastIndex-1 )        # swap posn
                    prevFrame.grid( row=lastIndex )

                lastIndex -= 1
                if lastIndex < 1:
                    break

        # E|sort

        update_materials_list()

        notification( f'"{o.name}" added to the list!' )

    else:
        messagebox.showerror( 'Access denied', f'"{o.name}" has already been added to the list!' )


# E|add_selection()



"""
S|update_materials_list()

    lists the breakdown of materials & quantity from the selected outpost/research/materials items

"""
def update_materials_list():
    global _top1, _w1, resDir, consoleModItemCount

    # ech_debug( 'update_materials_list()' )

    for cItem in _w1.CheckList.winfo_children():
        cItem.destroy()

    _w1.CheckList.configure(height=1)                   # make scrollbar disappear
    _w1.Canvas.yview_moveto(0)

    _w1.ResourceCheckbox = {}

    rowCounter = 0
    resList = enum_selected_items()['items']
    if resList:
        # ech_debug( f'consoleModItemCount: {consoleModItemCount}' )
        # S|create an overlay saying modded items are in the list
        if consoleModItemCount > 0:
            # ech_debug( f'width: {get_selected_list().winfo_width()}' )
            _w1.CheckList.warningMsg = tk.Label(_w1.CheckList, text='MODDED item(s) selected!\nKindly run the console commands as a batch file.', font='Arial 11', anchor='center', pady=10)
            _w1.CheckList.warningMsg.configure( wraplength=get_selected_list().winfo_width() )
            _w1.CheckList.warningMsg.grid(row=0, column=0, sticky='news')
            _w1.CheckList.grid_columnconfigure(0, weight=1)
            _w1.CheckList.grid_rowconfigure(0, weight=1)
        # E|create an overlay saying modded items are in the list
        else:
        # S|enumerate materials
            for res in resList:
                # ech_debug( f'{res["name"]:<20}    {res["q"]}    {res["ico"]}'  )

                _w1.ResourceCheckbox[rowCounter] = { 'cb': tk.BooleanVar(), 'id': res["id"] }

                checkbox = tk.Checkbutton(_w1.CheckList, anchor='center', variable=_w1.ResourceCheckbox[rowCounter]['cb'] )
                checkbox.grid(row=rowCounter, column=0, sticky='news')

                imgFile = f'{resDir}blank.png'
                itemName = tk.Label(_w1.CheckList, text=res["name"], font='Arial 10', padx=5, pady=1, height=30, compound='left', anchor='w')
                itemName._ico = tk.PhotoImage(file=imgFile, width=42, height=30)
                itemName.configure(image=itemName._ico)
                itemName.grid(row=rowCounter, column=1, sticky='ew')

                if res["ico"] != '' :
                    imgFile = f'{resDir}{res["ico"]}'
                    if os.path.exists(imgFile):
                        imgPil = Image.open(imgFile)
                        imgPil = imgPil.resize( (42, 30), Image.Resampling.LANCZOS )

                        # itemName._ico = tk.PhotoImage(file=imgPil, width=42, height=30)
                        itemName._ico = ImageTk.PhotoImage(imgPil)
                        itemName.configure(image=itemName._ico)

                itemQty = tk.Label(_w1.CheckList, text=f'x{res["q"]}', font='Arial 10', anchor='e', padx=10)
                itemQty.grid(row=rowCounter, column=2, sticky='news')

                if rowCounter % 2 == 0:
                    checkbox.configure(bg='#d9d9d9')
                    itemName.configure(bg='#d9d9d9')
                    itemQty.configure(bg='#d9d9d9')


                rowCounter += 1


        # E|enumerate materials

    _top1._hasChanged = True


# S|update_materials_list()



def clear_selection(event=None):
    global _top1, _w1
    global _cSelectedList

    # ech_debug('clear_selection()')

    for sItem in _cSelectedList.SelectedList.winfo_children():
        sItem.destroy()

    _cSelectedList.SelectedList.configure(height=1)     # make scrollbar disappear
    _cSelectedList.Canvas.yview_moveto(0)

    update_materials_list()


# S|notification()
def notification(msg, d=2000, w=400, h=50, callback=None):
    global _top1, _w1

    if not hasattr(_w1, '_notice'):

        m = _w1.top

        posX = round( m.winfo_x() + (m.winfo_width()/2) - (w/2) )
        posY = round( m.winfo_y() + (m.winfo_height()/2) - (h/2) )

        _n = tk.Tk()
        _n.withdraw()
        _n.iconbitmap("res/myIcon.ico")
        _n.title("Notification")
        _n.geometry( f'{w}x{h}+{posX}+{posY}' )            # always center to main app?
        _n.attributes('-toolwindow', True)
        _n.attributes('-topmost',True)

        _n.Message = tk.Text(_n, font=('Arial', 10), padx=10, pady=10, relief='raised', wrap='word' )
        _n.Message.place( x=0, y=0, relwidth=1, relheight=1 )

        _n.Message.tag_configure('tag-center', justify='center')

        _n.Message.insert( tk.END, msg, 'tag-center' )
        _n.Message.configure( state=DISABLED )

        _n.deiconify()
        _n.after(d, _n.destroy )

# E|notification()


# S|load_selected_list()
def load_selected_list(event=None):
    global _w1, saveList

    loadName = _w1.combobox.get()

    # ech_debug( f'load_selected_list(): {loadName}' )

    if loadName in saveList:
        _w1._notice = False

        clear_selection()           # clear list

        # add item
        for itemId in saveList[loadName]['selected']:       # change to saveList[loadName]['selected']
            itemQty = saveList[loadName]['selected'][itemId]
            # ech_debug( f'{itemId}: {itemQty}' )

            o = find_item_by_id(itemId)
            if o:
                add_selection( o, itemQty )

        # add saveList[loadName]['checked']
        idx = 0
        if 'checked' in saveList[loadName]:
            idx = 0
            while idx < len(_w1.ResourceCheckbox):
                if _w1.ResourceCheckbox[idx]['id'] in saveList[loadName]['checked']:
                    _w1.ResourceCheckbox[idx]['cb'].set(True)

                idx += 1

        del _w1._notice


# E|load_selected_list()



# S|save_current_list()
def save_current_list():
    global _top1, _w1, saveFile, saveList

    # ech_debug( 'save_current_list()' )

    saveName = _w1.combobox.get()               # will also refer to the 'new' label
    fileNameOK = False
    err = ''

    # ech_debug( f'Save Name: {saveName}' )

    try:
        validate_filename( saveName )
        fileNameOK = True
    except ValidationError as e:
        err = "{}\n".format(e)

    if fileNameOK:
        selList = get_selected_list()
        itemList = {}

        # change saveList[saveName] to change saveList[saveName]['selected'] = itemList, saveList[saveName]['checked'] = checkList

        for sItem in selList.winfo_children():
            itemId = sItem._o.id
            itemQty = sItem._o.quantity

            itemList[itemId] = itemQty

        # ech_debug( f'Selected Items: {itemList}' )

        # saveList[saveName] = itemList

        idx = 0
        checkList = {}
        while idx < len(_w1.ResourceCheckbox):
            # ech_debug( f'{idx}: {_w1.ResourceCheckbox[idx]["id"]}:{_w1.ResourceCheckbox[idx]["cb"].get()}' )
            if _w1.ResourceCheckbox[idx]["cb"].get() == 1:
                # ech_debug( f'{idx}: {_w1.ResourceCheckbox[idx]["id"]}:{_w1.ResourceCheckbox[idx]["cb"].get()}' )
                checkList[_w1.ResourceCheckbox[idx]["id"]] = _w1.ResourceCheckbox[idx]["cb"].get()
            idx += 1

        saveList[saveName] = { 'selected': itemList, 'checked': checkList }
        save_json(saveList, saveFile)

        save_settings()

        # ech_debug( f'Current index: {_w1.SaveList.current(saveName)}' )
        # ech_debug( f'Current index: {_w1.SaveList["values"]}' )
        if saveName not in _w1.SaveList['values']:
            _w1.SaveList['values'] += (saveName, )
            _w1.SaveList.set( saveName )

        notification( f'"{saveName}" has been saved' )
    else:
        messagebox.showerror( 'Filename error', err )
        _w1.SaveList.set('')

        _w1.SaveList.focus()


    return True

# E|save_current_list()


# S|del_saved_list()
def del_saved_list():
    global _w1, saveFile, saveList, saveNameDefault

    # ech_debug( 'del_saved_list()' )

    loadName = _w1.combobox.get()

    delOK = False
    if loadName == saveNameDefault:                         # "Default" CANNOT be deleted
        notification( f'"{saveNameDefault}" is special and cannot be deleted! üòù' )
    else:
        delOK = True

    # confirm current selection to be deleted
    if delOK and not tk.messagebox.askyesno(title='Confirm delete', message=f'Are you sure you wish to delete "{loadName}"?'):
        delOK = False

    if delOK:
        del saveList[loadName]

        clear_selection()           # clear list

        save_json(saveList, saveFile)

        sList = []
        for saveId in saveList:
            sList.append(saveId)

        _w1.SaveList.configure(values=sList)            # update _w1.SaveList values
        _w1.SaveList.current(0)

        load_selected_list()                            # switch/load Default


    return delOK

# E|del_saved_list()


# S|create_new_list()
def create_new_list():
    global _top1, _w1

    # ech_debug( 'create_new_list()' )

    tooltipMsg = 'Type the new name for the list and click on the üíæ button to save the new list'
    notification( tooltipMsg, d=2000, h=75 )

    _w1.SaveList.configure(state='normal')
    _w1.SaveList.set('')

    _w1.SaveList.focus()


    return True

# E|create_new_list()


# S|save_to_file()
def save_to_file():
    global _top1, _w1

    saveName = _w1.combobox.get()               # will also refer to the 'new' label
    fileNameOK = False

    # ech_debug( f'save_to_file: {saveName}' )
    err = ''

    try:
        validate_filename( saveName )
        fileNameOK = True
    except ValidationError as e:
        err = "{}\n".format(e)

    if fileNameOK:
        selList = enum_selected_items()

        if len(selList['items_text']):
            fo = open( saveTemplate, 'r', encoding='utf-8')
            saveStr = fo.read()
            fo.close()

            newContent = saveStr.replace( '%selected_items%', selList['items_text'] ).replace( '%resources%', selList['resources'] ).replace( '%console_command%',  selList['console'] )

            fileName = saveDir + saveName + '.txt'
            with open(fileName, 'w', encoding='utf-8') as fo:
                fo.write( newContent )

            notification( f'Content has been saved to: "{fileName}"' )

        else:
            err = 'No content to save'

    if len(err):
        messagebox.showerror( 'Error in saving', err )


# E|save_to_file()


# S|copy_to_clipboard()
def copy_to_clipboard():
    global consoleModItemCount

    # ech_debug( 'copy_to_clipboard()' )

    msg = '*WARNING* Using console commands could break your game!\n\nThe console commands for the resources have been copied to the clipboard. You can now paste them in the Starfield console.'
    if consoleModItemCount:
        msg += '\n\nYou have selected a MODDED item. Unfortunately, \n\n    * Running these in the console may likely cause the game to FREEZE/CRASH.\n\n'
        msg += 'Save the commands in notepad and run it as a batch file in the console to be executed properly.'

    mats = enum_selected_items()

    # ech_debug( f'console command: {mats["console"]}' )

    if len( mats['console'] ):
        pyperclip.copy( mats['console'] )

        messagebox.showinfo( 'Console Commands', msg )
    else:
        messagebox.showerror( 'No item was selected', 'You have no selected items!' )

# E|copy_to_clipboard()


# S|load_url()
def load_url( webURL ):
    # ech_debug( f'load_url(): {webURL}')
    webbrowser.open_new( webURL )
# E|load_url()


# S|set_sash_pos()
def set_sash_pos(event=None):
    global _w1, config
    global saveSashPos

    pos = config.getint('SETTINGS', 'sash')

    _w1.TPanedwindow1.sashpos(0, pos)

    _w1.TPanedwindow1.unbind('<Map>')

    saveSashPos = True


    return True
# E|set_sash_pos()


# S|main()
def main(*args):
    '''Main entry point for the application.'''
    global root, saveFile, saveList, saveNameDefault, MAX_QTY
    global saveSashPos

    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , on_close)
    # Creates a toplevel widget.
    global _top1, _w1, config

    _top1 = root
    _top1._hasChanged = False

    load_config()

    MAX_QTY = config.getint("SETTINGS", "max_qty")
    if int(MAX_QTY) <= 255:
        MAX_QTY = 255

    # perksJSON = load_json( perksFile )

    # apply perks to outpost/research items

    if os.path.exists(saveFile):
        saveList = load_json(saveFile)

    _w1 = starfield_she.MainWindow(_top1)
    posX = config.getint("SETTINGS", "posx")
    posY = config.getint("SETTINGS", "posY")

    # ech_debug( f'{posX}, {posY}' )

    if posX == 1 and posY == 1:
        width = _w1.top.winfo_width()
        height = _w1.top.winfo_height()

        user32 = ctypes.windll.user32
        posX = int( (user32.GetSystemMetrics(0)/2) - (width/2) )
        posY = int( (user32.GetSystemMetrics(1)/2) - (height/2) )

    # ech_debug( screensize )

    set_win_pos(_w1.top, posX, posY)

    width = config.getint("SETTINGS", "width")
    height = config.getint("SETTINGS", "height")

    set_win_dimensions(_w1.top, width, height)

    load_json_data()

    create_tabs()       # populate tabs

    create_selected_list()
    
    saveSashPos = False
    
    selected_tab = config.getint('SETTINGS', 'tab')
    try:
        _w1.TNotebook1.select(selected_tab)
    except:
        _w1.TNotebook1.select(0)

    if _w1.TNotebook1.index("current") == 0:
        saveSashPos = True

    _w1.PrevButton.configure(command=prev_tab)
    _w1.NextButton.configure(command=next_tab)
    _w1.ClearButton.configure(command=clear_selection)

    sList = []
    selectedSave = 0
    if bool(saveList):
        # ech_debug('Enumerate savefile names and add to combobox')
        # set current from configparser
        selectedSave = config.getint('SETTINGS', 'selected_save')
        if selectedSave < 0:
            selectedSave = 0

        _w1._notice = False


        for saveName in saveList:
            # ech_debug( f'saveItem: {saveName}' )
            sList.append( saveName )

        # ech_debug( f'{saveName}: {saveList[saveName]}' )


        del _w1._notice

    else:
        sList.append( saveNameDefault )


    _w1.SaveList.configure(values=sList)                    # read from saveFile or use saveNameDefault
    try:
        _w1.SaveList.current(selectedSave)                      # get from config
    except:
        selectedSave = 0
        _w1.SaveList.current(selectedSave)

    _w1.SaveList.bind('<<ComboboxSelected>>', load_selected_list)

    about_win(create=True)

    load_selected_list()

    _w1.AboutBtn.configure(command=lambda: about_win(show=True) )
    _w1.SaveListBtn.configure(command=save_current_list)
    _w1.DelListBtn.configure(command=del_saved_list)
    _w1.NewListBtn.configure(command=create_new_list)

    _w1.SaveButton.configure(command=save_to_file)
    _w1.ConsoleCmdBtn.configure(command=copy_to_clipboard)
    
    _top1.aboutWin.githubBtn.configure( command=lambda: load_url('https://github.com/itnkd4iam/starfield_she') )
    _top1.aboutWin.myNFTBtn.configure( command=lambda: load_url('https://linktr.ee/iamai_nft') )
    _top1.aboutWin.tipMeBtn.configure( command=lambda: load_url('https://www.paypal.com/paypalme/ehalos/1?country.x=PH&locale.x=en_US') )


    # ech_debug( all_children( _w1.TPanedwindow1_p2 ) )

    _w1.top.update_idletasks()                              # wait for outpost/resources/research items to be listed

    _w1.top.deiconify()

    pos = config.getint('SETTINGS', 'sash')
    if pos > 0:
        _w1.TPanedwindow1.bind('<Map>', set_sash_pos, '+')

    # notification('App ready')

    """
    global _cSelectedList
    for item in _cSelectedList.SelectedList.winfo_children():
        ech_debug( f'{item.grid_info()["row"]:<3} {item.children["itemname"].cget("text")}' )
    """

    root.mainloop()

# E|main()


if __name__ == '__main__':
    starfield_she.start_up()

